import {
    appElement,
    renderChooseLevelModal,
    selectedLevel,
} from "../src/main.js";
import { cardsArray } from "./cardsArray.js";

let firstCard = null;
let secondCard = null;
let lockBoard = false;
let seconds = 0; // Добавлено: Переменная для хранения времени

export function renderPlayingFields() {
    // Генерируем игровое поле
    const cardArr = [];
    for (let i = 0; i < selectedLevel; i++) {
        cardArr.push(
            `<div class="card card_front" data-value="${cardsArray[i % (selectedLevel / 2)]}" style="background-image: url(${cardsArray[i % (selectedLevel / 2)]});"></div>`,
        );
    }

    const appHtml = `
        <div class='header'>
            <div class="stopwatch">
                <div class="time_text">
                    <span class="label">min</span>
                    <span class="label">sek</span>
                </div>
                <div class="display" id="display">00:00</div>
            </div>
            <button class='restart'>Начать заново</button>
        </div>
        <div class="cards">
        ${cardArr.join(" ")}
        </div>
        `;

    appElement.innerHTML = appHtml;
    const restartBtn = document.querySelector(".restart");
    const display = document.getElementById("display");

    // Добавлено: Вызов startGame после рендеринга поля
    startGame();
    // Добавлено: Запуск таймера после рендеринга поля
    startTimer();

    restartBtn.addEventListener("click", () => {
        renderChooseLevelModal({ appEl: appElement });
    });

    let timer; // Объявляем таймер здесь, чтобы он был доступен вне функции startTimer

    function startTimer() {
        seconds = 0; // Сбрасываем секунды при каждом запуске таймера
        clearInterval(timer); // Очищаем предыдущий таймер, чтобы избежать множественных интервалов
        timer = setInterval(() => {
            seconds++;
            updateDisplay();
        }, 1000);
    }

    function updateDisplay() {
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        display.textContent = `${String(minutes).padStart(2, "0")}:${String(remainingSeconds).padStart(2, "0")}`;
    }

    function startGame() {
        const selectedCard = cardsArray.slice(0, selectedLevel / 2); //создаем массив из количества карт деленных на 2
        const gameCards = [...selectedCard, ...selectedCard]; //копируем массив
        shuffleArray(gameCards);

        const gameFields = document.querySelector(".cards"); //получаем поле
        gameFields.innerHTML = ""; //очищаем поле

        gameCards.forEach((value) => {
            const card = document.createElement("div");
            card.classList.add("card");
            card.dataset.value = value;
            card.style.backgroundImage = `url(${value})`; // Устанавливаем изображение
            card.addEventListener("click", flipCard);
            gameFields.appendChild(card);
        });

        // Показываем карточки 5 секунд, потом скрываем их
        setTimeout(() => {
            const allCards = document.querySelectorAll(".card");
            allCards.forEach((card) => {
                card.style.backgroundImage = ""; // Скрываем изображение
                card.classList.remove("flipped"); // Убираем класс переворота
            });
        }, 5000);
    }

    function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [array[i], array[j]] = [array[j], array[i]];
        }
    }

    function flipCard(event) {
        if (lockBoard) return;
        if (!event.target.classList.contains("card")) return; // Проверяем, что кликнули именно по карточке
        const clickedCard = event.target;
        if (clickedCard === firstCard) return;

        clickedCard.classList.add("flipped");
        clickedCard.style.backgroundImage = `url(${clickedCard.dataset.value})`; // Показываем изображение

        if (!firstCard) {
            firstCard = clickedCard;
            return;
        }

        secondCard = clickedCard;
        lockBoard = true;

        checkForMatch();
    }

    function checkForMatch() {
        if (firstCard.dataset.value === secondCard.dataset.value) {
            disableCards();
        } else {
            unflipCards();
        }
    }

    function disableCards() {
        firstCard.removeEventListener("click", flipCard);
        secondCard.removeEventListener("click", flipCard);

        resetBoard();
        checkWin(); // Проверяем, выиграл ли игрок
    }

    function unflipCards() {
        setTimeout(() => {
            firstCard.style.backgroundImage = ""; // Скрываем изображение
            secondCard.style.backgroundImage = ""; // Скрываем изображение
            firstCard.classList.remove("flipped");
            secondCard.classList.remove("flipped");

            resetBoard();
        }, 1000);
    }

    function resetBoard() {
        [firstCard, secondCard] = [null, null];
        lockBoard = false;
    }
    function checkWin() {
        const flippedCards = document.querySelectorAll(".card.flipped");
        if (flippedCards.length === selectedLevel) {
            clearInterval(timer); // Останавливаем таймер
            alert(`Вы победили! Ваше время: ${display.textContent}`);
            resetGame();
        }
    }
    function resetGame() {
        clearInterval(timer);
        seconds = 0;
        updateDisplay();
        firstCard = null;
        secondCard = null;
        lockBoard = false;
        startGame();
        startTimer();
    }
}

Основные изменения и пояснения:



Вызов функций startGame() и startTimer() после рендеринга:

После того как DOM готов (поле отрендерено), необходимо запустить игру и таймер.

Добавлены переменные и функции для таймера:

Добавлена переменная seconds для отслеживания времени.

Функции startTimer (запускает таймер), updateDisplay (обновляет отображение времени) и clearInterval(timer) (очищает таймер при рестарте или победе).

Переписана логика flipCard():

Добавлена проверка, что клик произошел именно по карточке (event.target.classList.contains("card")).

Установка фона карточке при клике (отображение рубашки).

Вызов checkForMatch() после выбора второй карточки.

Функции для проверки соответствия карт:

checkForMatch(): Сравнивает значения карт и вызывает disableCards() или unflipCards().

disableCards():  Деактивирует карточки, чтобы на них нельзя было кликнуть, и вызывает resetBoard().

unflipCards():  Переворачивает карты рубашкой вверх, если они не совпадают, и вызывает resetBoard().

resetBoard(): Сбрасывает значения firstCard, secondCard и lockBoard.

Функция checkWin():

Проверяет, все ли карты открыты (имеют класс flipped).

Если все карты открыты, останавливает таймер и выводит сообщение о победе.

Функция resetGame():

Сбрасывает все переменные и запускает игру заново.

Удаление textContent и использование backgroundImage:

Вместо textContent используется изменение backgroundImage для показа и скрытия изображений карт.


Дополнительные пояснения:



lockBoard: Эта переменная предотвращает множественные клики, пока идет проверка или переворот карт.

[firstCard, secondCard] = [null, null]:  Это деструктурирующее присваивание, которое одновременно устанавливает firstCard и secondCard в null.

setTimeout: Используется для задержки перед тем, как перевернуть карты обратно или деактивировать их.


Логика игры:



Рендеринг поля:  Создается HTML для игрового поля на основе выбранного уровня сложности.

startGame():

Создает массив карт.

Перемешивает карты.

Отображает карты на поле на 5 секунд, затем скрывает их.

Клики по картам (flipCard()):

При клике на карту:

Проверяется, не заблокирована ли доска.

Проверяется, не является ли это повторный клик по той же карте.

Карта переворачивается (отображается изображение).

Если это первая карта, она запоминается.

Если это вторая карта, она запоминается, и доска блокируется.

Проверка на совпадение (checkForMatch()):

Если карты совпадают:

Они деактивируются.

Проверяется, выиграл ли игрок.

Если карты не совпадают:

Они переворачиваются обратно рубашкой вверх.

Проверка на выигрыш (checkWin()):

Если все карты открыты, игра заканчивается, и выводится сообщение о победе.
